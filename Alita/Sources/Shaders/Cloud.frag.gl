
#ifndef USE_NORMAL
#define USE_NORMAL 0
#endif

#ifndef USE_UV0
#define USE_UV0 0
#endif

layout(binding = 2) uniform ShadingBuffer
{
    vec4 emissiveFactor;
    vec4 baseColorFactor;
    float metallicFactor;
    float roughnessFactor;
}
uShading;

layout(location = 0) in vec4 _WorldPosition;
layout(location = 1) in vec2 _UV0;

layout(binding = 11) uniform texture3D tNoiseMap;
layout(binding = 12) uniform sampler sNoiseMap;

float sphereSDF(vec3 p) {
    return length(p) - 1.0;
}

float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}

float unionSDF(float distA, float distB) {
    return min(distA, distB);
}

float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

#define CloudStartHeight  100.0
#define CloudThickness 20.0

float SceneSDF(vec3 samplePoint) {
    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;
    return sphereDist;
}

bool GetDensity(in vec3 position, out float noise)
{
    if (position.y > CloudStartHeight + CloudThickness)
    {
        return false;
    }

    if (abs(position.x) > 1000 || abs(position.z) > 1000)
    {
        return false;
    }

    vec2 uv = position.xz / 300;
    float w = (position.y - CloudStartHeight) / CloudThickness;

    noise = texture(sampler3D(tNoiseMap, sNoiseMap), vec3(uv, w)).r;
    noise = clamp(noise, 0, 1);

    return true;
}

float GetCloundDensity(in vec3 origin, in vec3 direction)
{
    vec3 ray = normalize(direction);
    float noise = 0;
    if (ray.y <= 0)
    {
        return 0;
    }

    const int StepCount = 50;
    const float step = CloudThickness / (StepCount - 1);

    for (int i = 0; i < StepCount; ++i)
    {
        float cloudHeight = CloudStartHeight + i * step;
        float yLength = 0;
        if (ray.y > 0.999)
        {
            yLength = cloudHeight - origin.y;
        }
        else 
        {
            yLength = (cloudHeight - origin.y) / ray.y;
        }

        vec3 tracePosition = ray * yLength;

        float n = 0;
        if (!(GetDensity(tracePosition, n)))
        {
            break;
        }
        noise += n;
    }

    // vec3 startPos = ray * yLength;
    // if (abs(startPos.x) > 1000 || abs(startPos.z) > 1000)
    // {
    //     return 0;
    // }
    // vec2 uv = startPos.xz / 300;
    // noise = textureLod(sampler3D(tNoiseMap, sNoiseMap), vec3(uv, 0), 0);
    //     // noise += textureLod(sampler3D(tNoiseMap, sNoiseMap),  vec2(0.01, 0.03) + uv, 0);
    //     // noise /= 2;
    //     //noise = vec4(abs(uv), 0, 1);
    
    return noise / StepCount;
    // return noise.x;
}

bool RayMarching(in vec3 origin, in vec3 direction, out vec4 color)
{
    float depth = 0.1;
    const int MAX_MARCHING_STEPS = 32;
    const float EPSILON = 0.0001;
    const float end = 100;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++)
    {
        float dist = SceneSDF(origin + depth * direction);
        if (dist < EPSILON)
        {
            // We're inside the scene surface!
            color = vec4(1.0, 0, 0, 1);
            return true;
        }
        // Move along the view ray
        depth += dist;

        if (depth >= end)
        {
            // Gone too far; give up
            return false;
        }
    }
    return false;;
}

// output
layout(location = 0) out vec4 OutColor;

void TVolumeCloud()
{
    vec3 rayDirection = normalize(_WorldPosition.xyz - uGlobal.EyePos.xyz);
    // vec4 color ;
    // bool ret = RayMarching(uGlobal.EyePos.xyz, rayDirection, color);
    // if (ret)
    // {
    //     OutColor = color;
    // }
    // else 
    // {
    //     discard;
    // }

    float density = GetCloundDensity(uGlobal.EyePos.xyz, rayDirection);
    // OutColor = density;
    // if (density < 0.2)
    // {
    //     discard;
    // }
    OutColor = vec4(1, 1, 1, density);
    // if (_WorldPosition.y < 500)
    // {
    //     discard;
    // }
    // vec4 diffuse = texture(sampler2D(tNoiseMap, sNoiseMap), _UV0 * 10);
    // if (diffuse.r < 0.5)
    // {
    //     discard;
    // }
    // OutColor = vec4(diffuse.xyz, 0.2);
}
