
#ifndef USE_NORMAL
#define USE_NORMAL 0
#endif

#ifndef USE_UV0
#define USE_UV0 0
#endif

layout(binding = 2) uniform ShadingBuffer
{
    vec4 emissiveFactor;
    vec4 baseColorFactor;
    float metallicFactor;
    float roughnessFactor;
}
uShading;

layout(location = 0) in vec4 _WorldPosition;
layout(location = 1) in vec2 _UV0;

layout(binding = 11) uniform texture2D tNoiseMap;
layout(binding = 12) uniform sampler sNoiseMap;

float sphereSDF(vec3 p) {
    return length(p) - 1.0;
}

float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}

float unionSDF(float distA, float distB) {
    return min(distA, distB);
}

float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

float SceneSDF(vec3 samplePoint) {
    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;
    return sphereDist;
    // float cubeDist = cubeSDF(samplePoint) * 1.2;
    // return intersectSDF(cubeDist, sphereDist);
}

bool RayMarching(in vec3 origin, in vec3 direction, out vec4 color)
{
    float depth = 0.1;
    const int MAX_MARCHING_STEPS = 32;
    const float EPSILON = 0.0001;
    const float end = 100;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++)
    {
        float dist = SceneSDF(origin + depth * direction);
        if (dist < EPSILON)
        {
            // We're inside the scene surface!
            color = vec4(1.0, 0, 0, 1);
            return true;
        }
        // Move along the view ray
        depth += dist;

        if (depth >= end)
        {
            // Gone too far; give up
            return false;
        }
    }
    return false;;
}

// output
layout(location = 0) out vec4 OutColor;

void TVolumeCloud()
{
    vec3 rayDirection = normalize(_WorldPosition.xyz - uGlobal.EyePos.xyz);
    vec4 color ;
    bool ret = RayMarching(uGlobal.EyePos.xyz, rayDirection, color);
    if (ret)
    {
        OutColor = color;
    }
    else 
    {
        discard;
    }
    // if (_WorldPosition.y < 500)
    // {
    //     discard;
    // }
    // vec4 diffuse = texture(sampler2D(tNoiseMap, sNoiseMap), _UV0 * 10);
    // if (diffuse.r < 0.5)
    // {
    //     discard;
    // }
    // OutColor = vec4(diffuse.xyz, 0.2);
}
