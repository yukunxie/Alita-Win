// https://gist.github.com/galek/53557375251e1a942dfa

layout(location = 0) in vec2 _UV0;

layout(binding = 11) uniform texture2D   tGDiffuse;
layout(binding = 12) uniform sampler     sGDiffuse;
layout(binding = 13) uniform texture2D   tGEmissive;
layout(binding = 14) uniform sampler     sGEmissive;
layout(binding = 15) uniform texture2D   tGNormal;
layout(binding = 16) uniform sampler     sGNormal;
layout(binding = 17) uniform texture2D   tGPosition;
layout(binding = 18) uniform sampler     sGPosition;
layout(binding = 19) uniform texture2D   tGMaterial;
layout(binding = 20) uniform sampler     sGMaterial;
layout(binding = 21) uniform texture2D   tShadowMap;
layout(binding = 22) uniform sampler     sShadowMap;
layout(binding = 23) uniform texture2D   tIBLBrdfMap;
layout(binding = 24) uniform sampler     sIBLBrdfMap;
layout(binding = 25) uniform textureCube    tCubeMap;
layout(binding = 26) uniform sampler        sCubeMap;

layout(location = 0) out vec4 OutColor;

#define ShadowFactor 0.5

float textureProj(vec4 shadowCoord, vec2 off)
{
	float shadow = 1.0;
	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 ) 
	{
		float dist = texture(sampler2D(tShadowMap, sShadowMap), shadowCoord.xy + off ).r;
		if ( shadowCoord.w > 0.0 && dist < shadowCoord.z ) 
		{
			shadow = ShadowFactor;
		}
	}
	return shadow;
}

float filterPCF(vec4 sc)
{
	//ivec2 texDim = textureSize(sampler2D(tShadowMap, sShadowMap), 0);
    // float dx = scale / float(texDim.x);
	// float dy = scale / float(texDim.y);
	float scale = 1.0;
	float dx = scale / 2048.0;
    float dy = scale / 2048.0;

	float shadowFactor = 0.0;
	int count = 0;
	int range = 1;
	
	for (int x = -range; x <= range; x++)
	{
		for (int y = -range; y <= range; y++)
		{
			shadowFactor += textureProj(sc, vec2(dx*x, dy*y));
			count++;
		}
	
	}
	return shadowFactor / count;
}

#define COOK_GGX 1
#define COOK 1

#define PI 3.1415926


// constant light position, only one light source for testing (treated as point light)
const vec4 light_pos = vec4(-2, 3, -2, 1);


// handy value clamping to 0 - 1 range
float saturate(in float value)
{
    return clamp(value, 0.0, 1.0);
}


// phong (lambertian) diffuse term
float phong_diffuse()
{
    return (1.0 / PI);
}


// compute fresnel specular factor for given base specular and product
// product could be NdV or VdH depending on used technique
vec3 fresnel_factor(in vec3 f0, in float product)
{
    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));
}


// following functions are copies of UE4
// for computing cook-torrance specular lighting terms

float D_blinn(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float n = 2.0 / m2 - 2.0;
    return (n + 2.0) / (2.0 * PI) * pow(NdH, n);
}

float D_beckmann(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float NdH2 = NdH * NdH;
    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);
}

float D_GGX(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float d = (NdH * m2 - NdH) * NdH + 1.0;
    return m2 / (PI * d * d);
}

float G_schlick(in float roughness, in float NdV, in float NdL)
{
    float k = roughness * roughness * 0.5;
    float V = NdV * (1.0 - k) + k;
    float L = NdL * (1.0 - k) + k;
    return 0.25 / (V * L);
}


// simple phong specular calculation with normalization
vec3 phong_specular(in vec3 V, in vec3 L, in vec3 N, in vec3 specular, in float roughness)
{
    vec3 R = reflect(-L, N);
    float spec = max(0.0, dot(V, R));

    float k = 1.999 / (roughness * roughness);

    return min(1.0, 3.0 * 0.0398 * k) * pow(spec, min(10000.0, k)) * specular;
}

// simple blinn specular calculation with normalization
vec3 blinn_specular(in float NdH, in vec3 specular, in float roughness)
{
    float k = 1.999 / (roughness * roughness);
    
    return min(1.0, 3.0 * 0.0398 * k) * pow(NdH, min(10000.0, k)) * specular;
}

// cook-torrance specular calculation                      
vec3 cooktorrance_specular(in vec4 material, in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)
{
#ifdef COOK_BLINN
    float D = D_blinn(roughness, NdH);
#endif

#ifdef COOK_BECKMANN
    float D = D_beckmann(roughness, NdH);
#endif

#ifdef COOK_GGX
    float D = D_GGX(roughness, NdH);
#endif

    float G = G_schlick(roughness, NdV, NdL);

    float rim = mix(1.0 - roughness * material.w * 0.9, 1.0, NdV);

    return (1.0 / rim) * specular * G * D;
}

// TODO https://github.com/bwasty/gltf-viewer/blob/master/src/shaders/pbr-frag.glsl

void TShading() {
    //OutColor = texture(sampler2D(tGPosition, sGDiffuse), _UV0);

    vec3 diffuse = texture(sampler2D(tGDiffuse, sGDiffuse), _UV0).xyz;

    vec4 wp = texture(sampler2D(tGPosition, sGPosition), _UV0);
    vec3 _WorldPosition = wp.xyz;// / wp.w;
    vec3 _WorldNormal = texture(sampler2D(tGNormal, sGNormal), _UV0).xyz;
	vec3 N = _WorldNormal;//normalize(_WorldNormal);

	// x - metallic, y - roughness, w - "rim" lighting
	vec4 material = texture(sampler2D(tGMaterial, sGMaterial), _UV0);

	// material params
    float metallic = material.x;
	float roughness = material.y;

	vec3 L = normalize(-uGlobal.SunLight.xyz);
    vec3 V = normalize(uGlobal.EyePos.xyz - _WorldPosition);
    vec3 H = normalize(L + V);

// light attenuation
    float A = 1;//20.0 / dot(local_light_pos - v_pos, local_light_pos - v_pos);

    // mix between metal and non-metal material, for non-metal
    // constant base specular factor of 0.04 grey is used
    // vec3 specular = mix(vec3(0.04), diffuse, metallic);
    vec3 specular = diffuse;//mix(vec3(0.04), vec3(1), metallic);

	// diffuse IBL term
    //    I know that my IBL cubemap has diffuse pre-integrated value in 10th MIP level
    //    actually level selection should be tweakable or from separate diffuse cubemap
    vec3 envdiff = texture(samplerCube(tCubeMap, sCubeMap), _WorldNormal.xyz).xyz;

    // specular IBL term
    //    11 magic number is total MIP levels in cubemap, this is simplest way for picking
    //    MIP level from roughness value (but it's not correct, however it looks fine)
    vec3 refl = reflect(V, N);
    // vec3 envspec =textureLod(samplerCube(tCubeMap, sCubeMap), refl, roughness * 11.0).xyz;
	vec3 envspec = vec3(0);

	float NdL = max(0.0, dot(N, L));
    float NdV = max(0.001, dot(N, V));
    float NdH = max(0.001, dot(N, H));
    float HdV = max(0.001, dot(H, V));
    float LdV = max(0.001, dot(L, V));

#ifdef PHONG
    // specular reflectance with PHONG
    vec3 specfresnel = fresnel_factor(specular, NdV);
    vec3 specref = phong_specular(V, L, N, specfresnel, roughness);
#endif

#ifdef BLINN
    // specular reflectance with BLINN
    vec3 specfresnel = fresnel_factor(specular, HdV);
    vec3 specref = blinn_specular(NdH, specfresnel, roughness);
#endif

#ifdef COOK
    // specular reflectance with COOK-TORRANCE
    vec3 specfresnel = fresnel_factor(specular, HdV);
    vec3 specref = cooktorrance_specular(material, NdL, NdV, NdH, specfresnel, roughness);
#endif

    specref *= vec3(NdL);

	// compute lighting
    vec3 reflected_light = vec3(0);
    vec3 diffuse_light = vec3(0.5, 0.5, 0.5); // initial value == constant ambient light

    // point light
    vec3 light_color = vec3(1.0) * A;
    reflected_light += specref * uGlobal.SunLightColor.xyz;
    //diffuse_light += diffref * light_color;

    // IBL lighting
    vec2 brdf = texture(sampler2D(tIBLBrdfMap, sIBLBrdfMap), vec2(roughness, 1.0 - NdV)).xy;
    vec3 iblspec = min(vec3(0.99), fresnel_factor(specular, NdV) * brdf.x + brdf.y);
    reflected_light += iblspec * envspec;
    diffuse_light += envdiff * (1.0 / PI);

    // final result
    vec3 result = diffuse_light * mix(diffuse, vec3(0.0), metallic) + reflected_light;
	result += texture(sampler2D(tGEmissive, sGEmissive), _UV0).xyz;

	// vec3 result =  reflected_light;

    // OutColor = vec4(vec3(clamp(dot(N, L), 0.0, 1.0)), 1);
    OutColor = vec4(result, 1);


    // vec3 lightDir = normalize(uGlobal.EyePos.xyz - _WorldPosition);
    // float specular = clamp(dot(lightDir, normalize(_WorldNormal)), 0, 1);
    // diffuse.xyz *= specular * uGlobal.SunLightColor.xyz * uGlobal.SunLightColor.a;

    // vec4 p = uGlobal.ShadowViewProjMatrix * vec4(wp / wp.z);
    // p /= p.w;
    // vec2 projCoords= (p.xy + 1.0) * 0.5;
    
    // float shadowFactor = filterPCF(vec4(projCoords, p.z, 1.0));
    // // float shadowFactor = 1.0;
    // // float smDepth = texture(sampler2D(tShadowMap, sShadowMap), projCoords).r;
    // // if (p.z > smDepth)
    // // {
    // //     shadowFactor = 0.5;
    // // }

    // OutColor = vec4(diffuse * shadowFactor , 1.0);
}