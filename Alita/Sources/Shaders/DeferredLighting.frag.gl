// https://gist.github.com/galek/53557375251e1a942dfa

layout(location = 0) in vec2 _UV0;

layout(binding = 11) uniform texture2D   tGDiffuse;
layout(binding = 12) uniform sampler     sGDiffuse;
layout(binding = 13) uniform texture2D   tGEmissive;
layout(binding = 14) uniform sampler     sGEmissive;
layout(binding = 15) uniform texture2D   tGNormal;
layout(binding = 16) uniform sampler     sGNormal;
layout(binding = 17) uniform texture2D   tGPosition;
layout(binding = 18) uniform sampler     sGPosition;
layout(binding = 19) uniform texture2D   tGMaterial;
layout(binding = 20) uniform sampler     sGMaterial;
layout(binding = 21) uniform texture2D   tShadowMap;
layout(binding = 22) uniform sampler     sShadowMap;
layout(binding = 23) uniform texture2D   tIBLBrdfMap;
layout(binding = 24) uniform sampler     sIBLBrdfMap;
layout(binding = 25) uniform textureCube    tCubeMap;
layout(binding = 26) uniform sampler        sCubeMap;

layout(location = 0) out vec4 OutColor;

#define ShadowFactor 0.5

float textureProj(vec4 shadowCoord, vec2 off)
{
	float shadow = 1.0;
	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 ) 
	{
		float dist = texture(sampler2D(tShadowMap, sShadowMap), shadowCoord.xy + off ).r;
		if ( shadowCoord.w > 0.0 && dist < shadowCoord.z ) 
		{
			shadow = ShadowFactor;
		}
	}
	return shadow;
}

float filterPCF(vec4 sc)
{
	//ivec2 texDim = textureSize(sampler2D(tShadowMap, sShadowMap), 0);
    // float dx = scale / float(texDim.x);
	// float dy = scale / float(texDim.y);
	float scale = 1.0;
	float dx = scale / 2048.0;
    float dy = scale / 2048.0;

	float shadowFactor = 0.0;
	int count = 0;
	int range = 1;
	
	for (int x = -range; x <= range; x++)
	{
		for (int y = -range; y <= range; y++)
		{
			shadowFactor += textureProj(sc, vec2(dx*x, dy*y));
			count++;
		}
	
	}
	return shadowFactor / count;
}

#define COOK_GGX 1
#define COOK 1
#define USE_IBL 1

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec3 getNormal()
{
    vec3 _WorldNormal = texture(sampler2D(tGNormal, sGNormal), _UV0).xyz;
    return normalize(_WorldNormal);
}

#ifdef USE_IBL
// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
    float mipCount = 9.0; // resolution of 512x512
    float lod = (pbrInputs.perceptualRoughness * mipCount);
    // retrieve a scale and bias to F0. See [1], Figure 3
    vec3 brdf = texture(sampler2D(tIBLBrdfMap, sIBLBrdfMap), vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness)).rgb;
    vec3 diffuseLight = texture(samplerCube(tCubeMap, sCubeMap), n).rgb;

#ifdef USE_TEX_LOD
    vec3 specularLight = textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod).rgb;
#else
    vec3 specularLight = texture(samplerCube(tCubeMap, sCubeMap), reflection).rgb;
#endif

    vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
    vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);

    // // For presentation, this allows us to disable IBL terms
    // diffuse *= u_ScaleIBLAmbient.x;
    // specular *= u_ScaleIBLAmbient.y;

    return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (M_PI * f * f);
}


// TODO https://github.com/bwasty/gltf-viewer/blob/master/src/shaders/pbr-frag.glsl

void TShading() {
    vec4 material = texture(sampler2D(tGMaterial, sGMaterial), _UV0);
    float perceptualRoughness = material.g;
    float metallic = material.b;

    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec4 baseColor = texture(sampler2D(tGDiffuse, sGDiffuse), _UV0);

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec4 wp = texture(sampler2D(tGPosition, sGPosition), _UV0);
    vec3 _WorldPosition = wp.xyz / wp.w;

    vec3 n = getNormal();                             // normal at surface point
    vec3 v = normalize(uGlobal.EyePos.xyz - _WorldPosition);        // Vector from surface point to camera
    vec3 l = normalize(-uGlobal.SunLight.xyz);             // Vector from surface point to light
    vec3 h = normalize(l+v);                          // Half vector between both l and v
    vec3 reflection = -normalize(reflect(v, n));

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(
        NdotL,
        NdotV,
        NdotH,
        LdotH,
        VdotH,
        perceptualRoughness,
        metallic,
        specularEnvironmentR0,
        specularEnvironmentR90,
        alphaRoughness,
        diffuseColor,
        specularColor
    );

    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    vec3 color = NdotL * uGlobal.SunLightColor.xyz * (diffuseContrib + specContrib);

    vec3 u_AmbientLightColor = vec3(0.1);
    float u_AmbientLightIntensity = 1.0;

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    color += getIBLContribution(pbrInputs, n, reflection);
#else
    // Add simple ambient light
    color += u_AmbientLightColor * u_AmbientLightIntensity * baseColor.xyz;
#endif

    // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    float ao = texture(u_OcclusionSampler, v_UV[u_OcclusionTexCoord]).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

    color += texture(sampler2D(tGEmissive, sGEmissive), _UV0).xyz;

    OutColor = vec4(color, 1.0);


//     //OutColor = texture(sampler2D(tGPosition, sGDiffuse), _UV0);

//     vec3 diffuse = texture(sampler2D(tGDiffuse, sGDiffuse), _UV0).xyz;

//     vec4 wp = texture(sampler2D(tGPosition, sGPosition), _UV0);
//     vec3 _WorldPosition = wp.xyz;// / wp.w;
//     vec3 _WorldNormal = texture(sampler2D(tGNormal, sGNormal), _UV0).xyz;
// 	vec3 N = _WorldNormal;//normalize(_WorldNormal);

// 	// x - metallic, y - roughness, w - "rim" lighting
// 	vec4 material = texture(sampler2D(tGMaterial, sGMaterial), _UV0);

// 	// material params
//     float metallic = material.x;
// 	float roughness = material.y;

// 	vec3 L = normalize(-uGlobal.SunLight.xyz);
//     vec3 V = normalize(uGlobal.EyePos.xyz - _WorldPosition);
//     vec3 H = normalize(L + V);

// // light attenuation
//     float A = 1;//20.0 / dot(local_light_pos - v_pos, local_light_pos - v_pos);

//     // mix between metal and non-metal material, for non-metal
//     // constant base specular factor of 0.04 grey is used
//     // vec3 specular = mix(vec3(0.04), diffuse, metallic);
//     vec3 specular = diffuse;//mix(vec3(0.04), vec3(1), metallic);

// 	// diffuse IBL term
//     //    I know that my IBL cubemap has diffuse pre-integrated value in 10th MIP level
//     //    actually level selection should be tweakable or from separate diffuse cubemap
//     vec3 envdiff = texture(samplerCube(tCubeMap, sCubeMap), _WorldNormal.xyz).xyz;

//     // specular IBL term
//     //    11 magic number is total MIP levels in cubemap, this is simplest way for picking
//     //    MIP level from roughness value (but it's not correct, however it looks fine)
//     vec3 refl = reflect(V, N);
//     // vec3 envspec =textureLod(samplerCube(tCubeMap, sCubeMap), refl, roughness * 11.0).xyz;
// 	vec3 envspec = vec3(0);

// 	float NdL = max(0.0, dot(N, L));
//     float NdV = max(0.001, dot(N, V));
//     float NdH = max(0.001, dot(N, H));
//     float HdV = max(0.001, dot(H, V));
//     float LdV = max(0.001, dot(L, V));

// #ifdef PHONG
//     // specular reflectance with PHONG
//     vec3 specfresnel = fresnel_factor(specular, NdV);
//     vec3 specref = phong_specular(V, L, N, specfresnel, roughness);
// #endif

// #ifdef BLINN
//     // specular reflectance with BLINN
//     vec3 specfresnel = fresnel_factor(specular, HdV);
//     vec3 specref = blinn_specular(NdH, specfresnel, roughness);
// #endif

// #ifdef COOK
//     // specular reflectance with COOK-TORRANCE
//     vec3 specfresnel = fresnel_factor(specular, HdV);
//     vec3 specref = cooktorrance_specular(material, NdL, NdV, NdH, specfresnel, roughness);
// #endif

//     specref *= vec3(NdL);

// 	// compute lighting
//     vec3 reflected_light = vec3(0);
//     vec3 diffuse_light = vec3(0.5, 0.5, 0.5); // initial value == constant ambient light

//     // point light
//     vec3 light_color = vec3(1.0) * A;
//     reflected_light += specref * uGlobal.SunLightColor.xyz;
//     //diffuse_light += diffref * light_color;

//     // IBL lighting
//     vec2 brdf = texture(sampler2D(tIBLBrdfMap, sIBLBrdfMap), vec2(roughness, 1.0 - NdV)).xy;
//     vec3 iblspec = min(vec3(0.99), fresnel_factor(specular, NdV) * brdf.x + brdf.y);
//     reflected_light += iblspec * envspec;
//     diffuse_light += envdiff * (1.0 / PI);

//     // final result
//     vec3 result = diffuse_light * mix(diffuse, vec3(0.0), metallic) + reflected_light;
// 	result += texture(sampler2D(tGEmissive, sGEmissive), _UV0).xyz;

// 	// vec3 result =  reflected_light;

//     // OutColor = vec4(vec3(clamp(dot(N, L), 0.0, 1.0)), 1);
//     OutColor = vec4(result, 1);


//     // vec3 lightDir = normalize(uGlobal.EyePos.xyz - _WorldPosition);
//     // float specular = clamp(dot(lightDir, normalize(_WorldNormal)), 0, 1);
//     // diffuse.xyz *= specular * uGlobal.SunLightColor.xyz * uGlobal.SunLightColor.a;

//     // vec4 p = uGlobal.ShadowViewProjMatrix * vec4(wp / wp.z);
//     // p /= p.w;
//     // vec2 projCoords= (p.xy + 1.0) * 0.5;
    
//     // float shadowFactor = filterPCF(vec4(projCoords, p.z, 1.0));
//     // // float shadowFactor = 1.0;
//     // // float smDepth = texture(sampler2D(tShadowMap, sShadowMap), projCoords).r;
//     // // if (p.z > smDepth)
//     // // {
//     // //     shadowFactor = 0.5;
//     // // }

//     // OutColor = vec4(diffuse * shadowFactor , 1.0);
}